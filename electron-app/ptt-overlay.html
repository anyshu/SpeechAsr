<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PTT Overlay</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none;
    }
    body {
      background: transparent;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      pointer-events: none;
    }
    .overlay {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.03);
      color: #f8fafc;
      box-shadow: 0 10px 22px rgba(15, 23, 42, 0.32);
      width: 360px;
      max-width: 360px;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: none;
    }
    .overlay.show {
      opacity: 1;
      transform: translateY(0);
    }
    .indicator {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #ef4444;
      box-shadow: 0 0 0 6px rgba(239, 68, 68, 0.12);
      animation: pttPulse 1s ease-in-out infinite;
      flex-shrink: 0;
    }
    /* 内容区域容器 */
    .content-area {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .title {
      font-size: 10px;
      letter-spacing: 0.2px;
      color: #cbd5e1;
      text-transform: none;
      font-weight: 600;
    }
    /* Sliding window container - 遮罩区域，宽度等于小窗宽度 */
    .state-wrap {
      overflow-x: auto;
      overflow-y: hidden;
      position: relative;
      width: 316px; /* = 360px - indicator(10px) - gap(10px) - padding(24px) */
      max-width: 316px;
      height: 1.4em;
      display: flex;
      align-items: center;
      /* 隐藏滚动条但保持滚动功能 */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    .state-wrap::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }
    .state-inner {
      display: inline-block;
      white-space: nowrap;
      padding-left: 0;
      padding-right: 8px;
      font-size: 12px;
      line-height: 1.2;
      flex-shrink: 0; /* 防止 flex 容器压缩子元素 */
    }
    /* Left fade mask to visually hide old content - 覆盖整个遮罩区域 */
    .state-wrap::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 80px; /* 更宽的渐变遮罩区域 */
      pointer-events: none;
      background: linear-gradient(to right, rgba(15,23,42,0.95), rgba(15,23,42,0));
      transition: opacity 160ms ease;
    }
    .state-wrap.paused::before { opacity: 0.12; }
    .state-wrap.expanded { max-width: 316px; }
    .overlay[data-state="processing"] .indicator {
      background: #f59e0b;
      box-shadow: 0 0 0 6px rgba(245, 158, 11, 0.2);
      animation: pttPulseAmber 1.2s ease-in-out infinite;
    }
    .overlay[data-state="processing"] .state-inner {
      color: #fde68a;
    }
    .overlay[data-state="done"] .indicator {
      background: #22c55e;
      box-shadow: 0 0 0 6px rgba(34, 197, 94, 0.18);
      animation: none;
    }
    .overlay[data-state="done"] .state-inner {
      color: #bbf7d0;
    }
    .overlay[data-state="error"] .indicator {
      background: #ef4444;
      box-shadow: 0 0 0 6px rgba(239, 68, 68, 0.25);
      animation: none;
    }
    .overlay[data-state="error"] .state-inner {
      color: #fecdd3;
    }
    @keyframes pttPulse {
      0% { transform: scale(1); box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2); }
      50% { transform: scale(1.18); box-shadow: 0 0 0 8px rgba(239, 68, 68, 0.08); }
      100% { transform: scale(1); box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2); }
    }
    @keyframes pttPulseAmber {
      0% { transform: scale(1); box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.2); }
      50% { transform: scale(1.18); box-shadow: 0 0 0 8px rgba(245, 158, 11, 0.1); }
      100% { transform: scale(1); box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.2); }
    }
  </style>
</head>
<body>
    <div class="overlay" id="overlay" data-state="idle">
      <div class="indicator" id="indicator"></div>
      <div class="content-area">
        <!-- `hintText` will show duration label like: 按键录音 00:00:00.123 -->
        <div class="title" id="hintText">按键录音</div>

        <!-- sliding window: fixed container -> inner long line (white-space:nowrap) -->
        <div class="state-wrap" id="stateWrap" title="悬停暂停自动滚动，点击切换展开/收缩">
          <div class="state-inner" id="stateInner">等待中</div>
        </div>
      </div>
    </div>
    <script>
      const overlay = document.getElementById('overlay');
      const stateWrap = document.getElementById('stateWrap');
      const stateInner = document.getElementById('stateInner');
      const hintText = document.getElementById('hintText');

      // Auto-scroll control
      let autoScrollPaused = false;
      let scrollThrottleTimer = null;
      const SCROLL_THROTTLE_MS = 80; // throttle updates to avoid jank

      function doScrollToRight() {
        try {
          // 立即滚动到最右侧
          stateWrap.scrollLeft = stateWrap.scrollWidth;
          console.log('[doScrollToRight] scrollLeft:', stateWrap.scrollLeft, 'scrollWidth:', stateWrap.scrollWidth);
          // 使用 requestAnimationFrame 确保在布局更新后再次滚动
          requestAnimationFrame(() => {
            stateWrap.scrollLeft = stateWrap.scrollWidth;
            console.log('[doScrollToRight] after RAF scrollLeft:', stateWrap.scrollLeft);
          });
        } catch (e) {
          console.error('[doScrollToRight] Error:', e);
        }
      }

      function scheduleScroll() {
        if (autoScrollPaused) return;
        // 立即执行滚动，不使用节流，确保最新内容可见
        doScrollToRight();
      }

      function setOverlayMessage(text) {
        // Replace content (one-pass text). If you prefer incremental append,
        // change this to append fragments instead.
        const oldText = stateInner.textContent;
        stateInner.textContent = text || '';
        console.log('[setOverlayMessage]', { text, oldText, scrollWidth: stateWrap.scrollWidth, scrollLeft: stateWrap.scrollLeft });
        // 只有文本真正变化时才滚动
        if (text !== oldText && !autoScrollPaused) {
          scheduleScroll();
        }
      }

      // Hover to pause auto-scroll and reveal left context (weaken mask)
      stateWrap.addEventListener('mouseenter', () => {
        autoScrollPaused = true;
        stateWrap.classList.add('paused');
      });
      stateWrap.addEventListener('mouseleave', () => {
        autoScrollPaused = false;
        stateWrap.classList.remove('paused');
        // snap to latest after resuming
        doScrollToRight();
      });

      // Click to toggle expanded (local visual; actual window size may still be limited)
      stateWrap.addEventListener('click', () => {
        const expanded = stateWrap.classList.toggle('expanded');
        if (expanded) {
          stateWrap.classList.add('expanded');
          // ensure newest visible
          doScrollToRight();
        } else {
          stateWrap.classList.remove('expanded');
          doScrollToRight();
        }
      });

      function applyOverlay(payload = {}) {
        console.log('[applyOverlay] Called with:', payload);
        const state = payload.state || 'recording';
        // `message` is used for one-pass ASR text (may be empty string)
        const message = payload.message !== undefined ? payload.message : (state === 'processing' ? '正在识别...' : state === 'done' ? '识别完成' : state === 'error' ? '录音失败' : '正在录音...');
        // `hint` is used as the title/duration label when recording
        const hint = payload.hint !== undefined ? payload.hint : (state === 'processing' ? '稍等片刻' : '松开设定按键以结束');

        overlay.dataset.state = state;
        // hintText shows the duration label (e.g. 按键录音 00:00:00.123)
        hintText.textContent = hint || '';
        // stateInner shows the one-pass ASR content or status message
        setOverlayMessage(message || '');

        if (state === 'idle') {
          overlay.classList.remove('show');
        } else {
          overlay.classList.add('show');
        }
      }

      window.overlayAPI?.onUpdate?.((payload) => {
        console.log('[overlay:update] Event received:', payload);
        applyOverlay(payload);
      });

      // 初始化为隐藏
      applyOverlay({ state: 'idle' });
    </script>
</body>
</html>
